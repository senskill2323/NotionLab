---
title: "Live Chat - Database Notes"
version: "2"
date: "2025-10-09"
owner: "NEEDS-VERIFY Provide owner or primary contact."
description: Live Chat tables, RPCs and grants for client and admin surfaces.
---

<!-- AUTO:BEGIN -->
<!-- ANCHOR:LIVE_CHAT_DB -->
- Core tables
  - `public.chat_conversations`
    - `id uuid`
    - `guest_id uuid` (profiles.id ou `profiles.chat_guest_id` pour les comptes anonymises)
    - `guest_email text`
    - `staff_user_id uuid references public.profiles(id)`
    - `status text` dans { `ouvert`,`en_cours`,`a_traiter`,`resolu`,`abandonne` }
    - `client_archived boolean default false`, `admin_archived boolean default false`
    - `client_last_viewed_at timestamptz`, `admin_last_viewed_at timestamptz`
  - `public.chat_messages`
    - `id uuid`, `conversation_id uuid references public.chat_conversations(id)`
    - `sender text` (`user` ou `admin|owner|prof`), `content text`, `file_url text`, `file_type text`, `resource_id uuid`, `created_at timestamptz`

- RPC overview
  - `get_chat_conversations_with_details()` -> liste cote client scopee par `auth.uid()`/email + `has_unread`
  - `client_list_chat_staff_users()` -> staff actifs (`owner|admin|prof`)
  - `client_start_chat_conversation(p_staff_user_id uuid default null, p_force_new boolean default false)` -> reuse ou cree un fil; reouvre `resolu|abandonne`, remet `client_archived=false`
  - `client_chat_set_archived(p_conversation_id uuid, p_archived boolean)` -> unique chemin pour l'archivage client, verifie guest/email
  - `admin_chat_set_archived(p_id uuid, p_archived boolean)` -> toggle admin (security definer)
  - `admin_get_chat_conversations_with_details(p_archived boolean default null, p_limit integer default 50, p_offset integer default 0)` -> listing staff + `has_unread` calcule sur `sender='user'`
  - `admin_list_chat_recipients()` -> destinataires staff/clients pour la creation cote admin
  - A introduire: `client_mark_chat_viewed(conversation_id uuid)` et `admin_mark_chat_viewed(conversation_id uuid)` (security definer) pour remplacer les updates directes de `*_last_viewed_at` sous RLS

- RLS & grants
  - Activer `row level security` sur `public.chat_conversations` et `public.chat_messages` (`alter table ... enable row level security`) avant l'ajout de nouvelles policies.
  - Policies attendues sur `chat_conversations`:
    - Clients: lecture/update limitees aux conversations dont `guest_id = auth.uid()` ou `guest_email` = lower(`auth.email()`) ou `profiles.chat_guest_id`.
    - Staff: lecture/update pour `owner|admin|prof` (via `profiles.user_type` / `user_types.type_name`).
    - Widget visiteur: filtre sur `guest_id` alimente par l'identifiant localStorage.
  - Policies `chat_messages`:
    - Insert `sender='user'` autorise seulement si l'utilisateur possede la conversation.
    - Insert `sender in ('admin','owner','prof')` autorise uniquement pour le staff.
    - Select restreint aux memes predicate que `chat_conversations`.
  - Grants complementaires:
    - `authenticated` conserve `update(client_archived, client_last_viewed_at)` mais les frontends doivent passer par les RPC `client_mark_chat_viewed` / `admin_mark_chat_viewed` (security definer) pour respecter RLS.
    - Aucun composant ne manipule directement `chat_messages` / `chat_conversations` hors `chatApi`.
  - `sender` doit rester dans {`user`,`admin`,`owner`,`prof`}; refuser tout alias (ex: `guest`, prenom) sous peine de casser `has_unread` et les jointures staff.

- Maintenance
  - Alignement legacy statuts: `update public.chat_conversations set status='ouvert' where status='open';` (voir `Supabase/migrations/2025-10-07_align_chat_statuses.sql`)
  - Index: `chat_conversations_staff_user_idx`, `chat_conversations_client_last_viewed_idx` existent; ajouter `create index if not exists chat_messages_conversation_created_idx on public.chat_messages(conversation_id, created_at desc)` si le volume augmente.
<!-- AUTO:END -->
