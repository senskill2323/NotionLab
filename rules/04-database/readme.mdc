---
title: "NotionLab Guide IA - Module Formations"
version: "2"
date: "2025-01-18"
owner: "NEEDS-VERIFY Provide owner or primary contact."
description: Schéma Postgres/Supabase structuré, RLS sécurisé, migrations et seeds, triggers/RPC, sauvegardes et PITR, anonymisation, audit logs avec horodatage et soft-delete.
---

<!-- AUTO:BEGIN -->
<!-- ANCHOR:OVERVIEW -->
Supabase pilote la couche donnees du module Formations : tables courses et formation_module_statuses, RPC dedies, fonctions edge et migrations versionnees.

<!-- ANCHOR:STANDARDS -->
- Tables clefs : courses, user_courses, builder_families/subfamilies/modules, modules_registry, admin_dashboard_tabs, resources, formation_module_statuses.
- role_permissions et user_types alimentent PermissionsContext pour appliquer les gardes de routes.
- Les policies RLS sur formation_module_statuses isolent les utilisateurs au niveau Kanban.
- Thèmes UI : table `public.themes` (id uuid, name, tokens jsonb, is_default bool, timestamps) versionnee via `Supabase/migrations/2025-09-18_themes_and_rpcs.sql`.
- RPCs thèmes: `get_active_theme_tokens()` (lecture tokens jsonb) et `set_active_theme(p_theme_id uuid)` (active un thème). `set_active_theme` est restreint aux admins/owners.
- Fonction helper: `public.is_admin_or_owner(uid)` recommandee pour policies/RPC (cf. RLS ci-dessous).
- RLS `public.themes`: lecture/écriture réservées aux admins/owners; les clients non-admin lisent via le RPC `get_active_theme_tokens()` (security definer + GRANT EXECUTE à anon/authenticated).
- Assistant (mémoire & RLS):
  - Table `public.assistant_memories` (user_id uuid PK → auth.users(id) on delete cascade, data jsonb not null default '{}', updated_at timestamptz default now()).
  - RLS: policies « own only » (select/insert/update si `auth.uid() = user_id`). Index sur `updated_at` utile.
  - Edge Function `memory`: `action = 'get'|'update'`; fusion côté serveur pour éviter l’écrasement, ne jamais stocker d’informations sensibles.
 - Assistant (Realtime & RAG):
  - Edge Function `realtime-offer`: proxy WebRTC vers OpenAI Realtime. Vérifie l’utilisateur et `profiles.user_type ∈ {owner, admin, client}`; retourne SDP answer. La clé OPENAI n’est jamais exposée.
  - Edge Function `rag-search`: proxy vers `N8N_RAG_WEBHOOK_URL` avec `{ query, includeSources, image?, file? }`; renvoie `{ answer, sources? }`. En cas d’indisponibilité, `unavailable=true`.

- Datastore Assistant (Supabase sur docker sur VPS ) — séparé du du projet Supabase NotionLab qui est sur Supabase Cloud:
  - Extensions activées: `vector` (embeddings) et `pg_trgm` (recherches texte). À activer sur le projet Supabase du VPS n8n, pas sur le Cloud NotionLab.
  - Tables principales:
    - `resources`: bibliothèque RAG (titres, contenu, url?, tags, embedding dimension 1536). Index vectoriel (ex: ivfflat) sur `embedding` et index(s) sur `title`/`tags`.
    - `assistant_memory`: mémoire longue par utilisateur (clé/valeur JSON). RLS: `auth.uid() = user_id` pour SELECT/INSERT/UPDATE.
    - `conversations` (optionnelle): journal des messages (qui/quoi/quand). RLS: « own only ».
  - Fonction SQL `match_resources(query_emb, top_k, in_tags, in_collection)`: prend un embedding de requête et retourne les meilleurs passages/sources. Exposée via PostgREST; appelée par n8n pour construire `{ passages, sources }`.
  - Orchestration: le webhook n8n reçoit `{ query, userId, top_k }`, génère l’embedding (OpenAI), appelle `match_resources`, formate `{ passages, sources }` et répond. L’Edge Function `rag-search` consomme cette réponse.
  - IMPORTANT: Ne pas appliquer ces tables/policies/extensions au Supabase NotionLab Cloud. Ce sont des ressources du projet Supabase VPS (stack n8n) uniquement.
  - Séparation de COMPTES: le Supabase NotionLab (Cloud) et le Supabase VPS (Docker avec n8n) appartiennent à des comptes Supabase différents. Ne jamais mélanger migrations, secrets, ni accès PostgREST entre ces comptes.
  - RLS supplémentaires (recommandation):
    - `resources`: lecture autorisée aux utilisateurs authentifiés (rôles owner/admin/client) — SELECT si `auth.role() in ('authenticated')` et éventuellement filtrage par tags/collection.
    - `conversations`: SELECT/INSERT/UPDATE autorisés uniquement pour `auth.uid() = user_id`.
  - Indexation recommandée:
    - `create index if not exists resources_title_trgm_idx on resources using gin (title gin_trgm_ops);`
    - `create index if not exists resources_tags_gin_idx on resources using gin (tags);`
    - `create index if not exists resources_embedding_idx on resources using ivfflat (embedding vector_cosine_ops);`
- Onboarding formation (schéma & RLS):
  - Tables: `training_onboarding_sections`, `training_onboarding_questions`, `training_onboarding_question_options`, `training_onboarding_responses`, `training_onboarding_nps`.
  - Index d'ordre: `training_onboarding_questions_section_order_idx`, `training_onboarding_question_options_question_order_idx`.
  - RLS: lecture pour tous (auth), écriture limitée (propre utilisateur) sur `training_onboarding_responses` et `training_onboarding_nps`; gestion admin (owner/admin/prof) sur sections/questions/options via policies dédiées.
  - Seeds: sections (10), questions/options conformes au brief, modules/permissions client (`modules_registry`, `role_permissions`) et entrée admin (`admin_modules_registry`).

<!-- ANCHOR:WORKFLOWS -->
- RPC client : get_user_courses_and_parcours(p_user_id uuid) retourne les formations inscrites et parcours custom.
- RPC admin : get_admin_formations_and_submissions() rassemble formations et soumissions avec displayId unique.
- RPC soumission : submit_user_parcours_for_validation(p_course_id uuid) (NEEDS-VERIFY) cree la soumission et fige le snapshot.
- RPC validation : approve_user_parcours_submission(p_submission_id uuid) (NEEDS-VERIFY) initialise Kanban et user_formations.
- RPC Kanban : init_kanban_statuses_for_submission(p_submission_id uuid) derive formation_module_statuses a partir du snapshot.
- Thèmes: la page Admin « Thèmes » met à jour `public.themes.tokens` (CRUD restreint RLS) et active un thème via `select set_active_theme(<uuid>)`. Lecture côté client via `select get_active_theme_tokens()`.
 - Onboarding formation:
   - Migration: `Supabase/migrations/2025-09-20_training_onboarding_form.sql` crée tables, indexes, policies RLS et seeds (sections, questions, options), ainsi que `modules_registry` + `role_permissions` + `admin_modules_registry`.
   - Flux data: upsert dans `training_onboarding_responses` (brouillon/soumission); première soumission conserve `first_submitted_at`, toute soumission met à jour `last_submitted_at`. NPS lié 1:1 à `responses`.
   - Profil: mise à jour de `profiles.profession` depuis la réponse `metier_activite` lors de la soumission.

<!-- ANCHOR:ACCOUNT_DELETION_DB -->
- RPC serveur de suppression totale: `public.admin_delete_user_full(p_user_id uuid)` [SECURITY DEFINER]
  - Autorisations (via `request.jwt.claims` + `public.profiles → user_types`):
    - un utilisateur peut se supprimer lui‑même;
    - `owner`/`admin` peuvent supprimer d’autres comptes;
    - seul un `owner` peut supprimer un `owner`.
  - Ordre de nettoyage (best‑effort, avec gestion d’erreurs non bloquantes):
    - `public.formation_module_statuses` (user_id)
    - `public.user_formation_snapshots` (user_id)
    - `public.formation_submissions` (user_id)
    - `public.user_formations` (user_id)
    - Parcours personnalisés créés par l’utilisateur (`public.courses` avec `author_id = p_user_id` et `course_type = 'custom'`) et leurs dépendances: `user_formation_snapshots`, `user_formations`, `formation_submissions`, puis `courses`
    - Tickets et dérivés: `public.ticket_replies` (user_id), `public.tickets` (user_id, assigned_to)
    - Journaux: `public.action_logs` (actor_id)
    - Chat: `public.chat_messages` des conversations de l’utilisateur puis `public.chat_conversations` (guest_id)
    - Profil: `public.profiles` (id)
    - Auth: `auth.admin.delete_user(p_user_id)` (supprime aussi `auth.identities`)
  - Droits d’exécution: `GRANT EXECUTE ON FUNCTION public.admin_delete_user_full(uuid) TO authenticated;`

- RPC de pré‑vérification d’email (inscription): `public.check_email_available(p_email text)` [SECURITY DEFINER]
  - Retourne `true` si l’email est libre, `false` sinon.
  - Vérifie `auth.users.email` et `auth.identities (provider='email', identity_data->>'email')` en minuscules.
  - Droits d’exécution: `GRANT EXECUTE ... TO anon, authenticated;`

<!-- ANCHOR:EXAMPLES -->
```sql
CREATE TABLE formation_module_statuses (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  submission_id uuid NOT NULL,
  module_uuid uuid NOT NULL,
  status text CHECK (status IN ('todo','in_progress','blocked','done')) DEFAULT 'todo',
  position integer DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(submission_id, module_uuid)
);

CREATE VIEW kanban_user_modules_v1 AS
SELECT
  fms.id as status_id,
  fms.user_id,
  fms.submission_id,
  fms.module_uuid,
  fms.status,
  fms.position,
  null::text as title,
  null::text as description,
  null::integer as duration
FROM formation_module_statuses fms;

-- RPCs thèmes
create or replace function public.get_active_theme_tokens()
returns jsonb language sql stable as $$
  select t.tokens from public.themes t where t.is_default is true order by t.updated_at desc limit 1
$$;

create or replace function public.set_active_theme(p_theme_id uuid)
returns void language plpgsql security definer as $$
begin
  update public.themes set is_default = false where is_default is true;
  update public.themes set is_default = true where id = p_theme_id;
end;$$;

-- VPS n8n uniquement — Datastore Assistant (extraits)
-- Extensions
create extension if not exists vector;
create extension if not exists pg_trgm;

-- Table resources (structure indicative)
create table if not exists public.resources (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  content text not null,
  url text,
  tags text[],
  embedding vector(1536),
  created_at timestamptz default now()
);
create index if not exists resources_embedding_idx on public.resources using ivfflat (embedding vector_cosine_ops);
create index if not exists resources_title_trgm_idx on public.resources using gin (title gin_trgm_ops);
create index if not exists resources_tags_gin_idx on public.resources using gin (tags);

-- Fonction de matching (signature indicative)
create or replace function public.match_resources(
  query_emb vector(1536),
  top_k int default 5,
  in_tags text[] default null,
  in_collection text default null
) returns table(id uuid, title text, content text, url text, score float)
language sql stable as $$
  select r.id, r.title, r.content, r.url,
         1 - (r.embedding <=> query_emb) as score
  from public.resources r
  where (in_tags is null or r.tags && in_tags)
  order by r.embedding <=> query_emb
  limit top_k
$$;

-- PostgREST: GET /rest/v1/rpc/match_resources?query_emb=...  (appels effectués par n8n)

-- Extrait Onboarding: réponses + NPS (simplifié)
create table if not exists public.training_onboarding_responses (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id),
  draft_answers jsonb not null default '{}'::jsonb,
  submitted_answers jsonb,
  status text not null default 'draft',
  draft_saved_at timestamptz not null default now(),
  first_submitted_at timestamptz,
  last_submitted_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique(user_id),
  check (status in ('draft','submitted'))
);

create table if not exists public.training_onboarding_nps (
  id uuid primary key default gen_random_uuid(),
  response_id uuid not null references public.training_onboarding_responses(id) on delete cascade,
  user_id uuid not null references auth.users(id),
  answer boolean,
  comment text,
  created_at timestamptz not null default now(),
  unique(response_id)
);

-- Policies (extrait):
create policy training_onboarding_responses_select_own on public.training_onboarding_responses for select using (user_id = auth.uid());
create policy training_onboarding_responses_insert_own on public.training_onboarding_responses for insert with check (user_id = auth.uid());
create policy training_onboarding_responses_update_own on public.training_onboarding_responses for update using (user_id = auth.uid()) with check (user_id = auth.uid());
```

<!-- ANCHOR:LIMITS -->
- Snapshot timing : un parcours modifie entre soumission et validation peut rendre le snapshot obsolet.
- Kanban orphelin : supprimer la formation apres creation du Kanban laisse des modules orphelins.
- Supabase/functions/set-user-password/index.ts force Password123! avant email de reset : durcir avant production.
- Supabase/functions/update-dashboard-layout/index.ts supprime puis reinserre pour contourner un trigger on update defectueux.
- .env.local contient SUPABASE_SERVICE_ROLE committe : verifier qu'il n'est pas embarque dans le build.
- Themes: si `set_active_theme` est expose sans RLS/policies adequates, risque d'activation par utilisateurs non autorises. Restreindre via RLS (admins/owners) et GRANT EXECUTE controle.
 - Onboarding: brief cible 4–6 étapes, seed en 10 sections; réduire via désactivation de sections/questions côté admin (le wizard masque les sections vides) ou regrouper côté UI.
 - Encodage FR: certains titres/libellés seedés affichent « ? »; prévoir migration corrective sans impacter `slug`/`value`.
<!-- AUTO:END -->
