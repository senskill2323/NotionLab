•	Workspace lives in C:\Users\yvallott\.codex\notionlab_010925; operate only inside this Vite/React (18) project via Windsurf, keeping readmeIA (file in the root of the project) as the canonical reference.
•	Favor functional, declarative React; stay modular (component → subcomponents → hooks/helpers → static data); centralize Supabase access and keep helpers pure.
•	Always source env values (e.g., VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY) through @/lib/customSupabaseClient; warn if missing; never hard-code keys or expose service-role secrets client-side.
•	Manage auth exclusively via SupabaseAuthContext/useAuth(); respect authReady/authLoading; on critical auth failures sign out and redirect /connexion.
•	Route protection uses <ProtectedRoute requiredPermission="…"> with PermissionsContext/hasPermission(); keep Admin vs Client content separated.
•	For data operations favor Supabase RPCs or Edge Functions (standard response { data, error }); keep client queries minimal/paginated; add DB indexes as needed before shipping.
•	Realtime: subscribe with supabase.channel(...).on('postgres_changes', …) only where required; name channels explicitly and clean them up on unmount.
•	Storage: keep DB/storage in sync (avatars, resources, chat/forum attachments) following bucket conventions.
•	Naming: DB objects snake_case, Edge Functions kebab-case; use Vite alias @ for imports.
•	UI: use Radix + Tailwind, react-hook-form, Zustand for shared state, framer-motion for subtle animations, @dnd-kit for drag/drop, React Flow for builders; keep interactions accessible.
•	Kanban/admin flows: reuse AdminKanbanView, UserKanbanDashboard, and related hooks; avoid duplicating logic—extend via composition.
•	On cache-sensitive updates call emitSessionRefresh or invalidate relevant queries; log structured errors and show user-friendly toasts (no sensitive details).
•	Database/RLS: assume operations must respect row-level security; escalate to Edge Functions when privileged access is required; use explicit upsert conflicts and enum defaults.
•	Component registries & dashboards: interact via component_rules, modules_registry, and dashboard RPCs/Edge Functions (get-dashboard-layout, update-dashboard-layout) instead of hard-coded toggles.
•	CI/dev: Node 20 pipeline runs npm ci, npm run build, deploys via FTPS; run local checks with npm run dev or npm run preview; SQL via npm run db:query/db:file.
•	Treat these rules plus readmeIA as the single source of truth; update them when new tables/RPCs/Edge Functions land.
