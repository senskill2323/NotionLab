Contexte & objectifs
•	Le module Formations gère des parcours standard publiés et des parcours custom construits par les clients.
•	Frontend React 18 / Vite 7, backend Supabase (auth, données, temps réel, stockage).

Principes généraux
•	Workspace : C:\dev\notionlab ; travailler uniquement dans ce projet Vite/React via VSCode.
•	Source of truth : dossier /rules. Toujours mettre à jour quand de nouvelles tables / RPC / Edge Functions arrivent.
•	Style React : fonctionnel, déclaratif, modulaire (composant → sous-composants → hooks/helpers → données statiques).
•	Nommage : objets DB en snake_case, Edge Functions en kebab-case, alias Vite @ pour les imports.

Environnement & secrets

•	Env via /.env & /.env.local (ex. VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY) ; alerter si manquants ; ne jamais exposer de clés service-role côté client.

Authentification & routes
•	Séparer strictement contenus Admin vs Client.
•	Les admins sont redirigés vers /admin/dashboard.


Données, RPC & Edge Functions
•	Favoriser RPCs et Edge Functions pour la logique métier et l’accès privilégié (RLS par défaut).
•	Ajouter index DB avant livraison si nécessaires.
•	Utiliser des upsert explicites et des enum defaults.


Realtime
•	Préférer broadcast channels : supabase.channel(...).on('broadcast', ...) avec ack/self ; nommer les canaux explicitement ; dispose on unmount.
•	N’utiliser postgres_changes que si inévitable.


Stockage
•	Garder DB et Storage en phase (avatars, ressources, pièces jointes chat/forum) selon conventions de buckets.


UI/UX & accessibilité
•	Stack UI : Radix + Tailwind, react-hook-form, Zustand (état partagé), framer-motion (animations subtiles), @dnd-kit (drag/drop), React Flow (builders).
•	Interactions accessibles (focus, rôles, labels).
•	Langue : français uniquement, tutoiement. Disclaimer minimal sous « Valider » interdisant les données sensibles.


Thème & CSS
•	Theme system : couleurs via variables CSS --colors-* injectées par ThemeContext (RPC get_active_theme_tokens) et utilisées via hsl(var(--colors-…)) dans tailwind.config.js. Fallbacks :root dans src/index.css pour éviter le flash initial.
•	Compat CSS : fournir la paire standard + préfixée pour backdrop-filter et text-size-adjust (-webkit-…).
•	ThemeProvider présent uniquement dans src/main.jsx (retiré de src/App.jsx) pour éviter doubles injections/effets de bord.


Kanban & dashboards
•	Réutiliser AdminKanbanView, UserKanbanDashboard + hooks associés ; ne pas dupliquer la logique, étendre par composition.
•	Interagir avec component_rules, modules_registry, et RPCs/EF dashboard (get-dashboard-layout, update-dashboard-layout) plutôt que des toggles en dur.


Cache, invalidation & logs
•	Sur mises à jour sensibles au cache : appeler emitSessionRefresh ou invalider les requêtes pertinentes.
•	Journaliser les erreurs de façon structurée ; toasts conviviaux (sans détails sensibles).


Sécurité DB & RLS
•	Tout doit respecter la RLS ; escalader en Edge Functions pour l’accès privilégié.


CI / Dév
•	Node 20 : pipeline npm ci → npm run build → déploiement FTPS.
•	Local : npm run dev / npm run preview ; SQL via npm run db:query / npm run db:file.


Workflows « Formations »
•	Cycle : brouillon client → soumission → validation admin → Kanban live synchronisé.
•	Onboarding formation
o	UI charge uniquement les questions actives (admin activable/désactivable).
o	Wizard non bloquant, autosauvegarde, résumé côté client + admin.
o	Soumission : upsert training_onboarding_responses, mise à jour éventuelle de profiles.profession (depuis metier_activite).
o	Notification via Edge Function notify-training-onboarding (Deno) conservant Resend.
	Secrets requis : RESEND_API_KEY, ONBOARDING_NOTIFICATION_EMAIL (fallback OWNER_EMAIL), ONBOARDING_EMAIL_FROM (fallback SENDER_EMAIL).
	CORS : POST, OPTIONS.
o	Restitution : page client « Mes préférences de formation » (bouton « Mettre à jour ») ; panneau admin « Brief & Profil » (lecture seule) dans le Kanban Formation Live.


Assistant IA (WebRTC Realtime)
•	Accès : bouton nav Assistant (component_key nav:assistant) et module dashboard client_ai_assistant.
•	Contexte : AssistantProvider (wrappé dans App.jsx) expose useAssistant() et encapsule Perfect Negotiation (peer « polite »).
•	Backend Supabase :
o	Tables : assistant_settings (config), assistant_limits (quotas par utilisateur), assistant_metrics (journal sessions).
o	Edge Function assistant-mint-key : clé éphémère Realtime (OpenAI) + ice_servers + flags (aucun secret côté client).
•	Quotas & métriques :
o	Garde locale (minutes/jour, sessions concurrentes, images/session) synchronisée avec assistant_limits.
o	Chaque session met à jour assistant_metrics (durée, images, bytes up/down, erreurs) et rafraîchit les compteurs.
•	UX : AssistantDrawer.jsx gère Appeler / Raccrocher / Webcam / Montrez-lui (images via DataChannel) ; AssistantPanel.jsx résume l’état et ouvre le drawer.


Invitations administrateur
•	UI : bouton « Inviter un utilisateur » (src/components/admin/UserManagementPanel.jsx) → Edge Function invite-user.
•	Serveur : Supabase/functions/invite-user/index.ts
o	auth.admin.inviteUserByEmail (création/ré-utilisation)
o	Mise à jour public.profiles (user_type_id client, status = 'active').
o	Secrets Edge : SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, optionnel INVITE_REDIRECT_URL (fallback /connexion).
•	Activation : plus de « guest » ; arrivée sur /activation-invitation pour définir le mot de passe (accès client déjà actif).


Suppression de compte (full delete)
•	Objectif : effacer Auth + identités + données domaine.
•	Déclencheurs UI :
o	UserManagementPanel.jsx (icône corbeille)
o	ManageUserPage.jsx (bouton supprimer)
o	DeleteAccountSection.jsx (auto-suppression)
o	Tous appellent supabase.rpc('admin_delete_user_full', { p_user_id }).
•	Orchestration serveur : RPC public.admin_delete_user_full(uuid) (SECURITY DEFINER)
o	Nettoie : formation_module_statuses, user_formation_snapshots, user_formations, formation_submissions, tickets, ticket_replies, action_logs, chat_messages, chat_conversations, courses custom (author_id = user, course_type='custom').
o	Supprime public.profiles puis auth.admin.delete_user(p_user_id) (inclut auth.identities).
•	Autorisations : utilisateur → auto-suppression ; owner/admin → suppression d’autrui ; seul un owner peut supprimer un owner.


"Live Chat - Architecture

- Surfaces
  - Client: `ClientLiveChatPage.jsx`, `modules/client-live-chat/useClientLiveChat.js`, `modules/client-live-chat/components/*`, helpers `src/lib/chatApi.js`
  - Admin: `components/admin/AdminLiveChatPanel.jsx`, `components/admin/chat/ConversationList.jsx`, `components/admin/AdminChatView.jsx`

- Conversation workflows
  - Client: bouton "Nouvelle conversation" (Radix Dialog) -> selection d'un staff via `client_list_chat_staff_users` -> RPC `client_start_chat_conversation` rouvre un fil archive ou en cree un avec `status='ouvert'`
  - Admin: dialog "Nouvelle conversation" -> destinataire via `admin_list_chat_recipients` -> `startAdminConversation({ staffUserId, recipient, forceNew })` cree ou reutilise un fil selon collision et drapeau `forceNew`
  - Tri des listes par `updated_at` desc. pour garder l'activite recente en tete; plusieurs fils paralleles par guest cote admin sont autorises

- Broadcast topology
  - Conversations client: topic `client-chat-conversations-{guestId|guestEmail}` emet les evenements `conversation`
  - Messages client: topic `client-chat-messages-{conversationId}` emet les evenements `message`
  - Hub admin: topic `chat-live-admin` relaie `conversation` et `message` pour toutes les equipes
  - Canaux configures avec `{ broadcast: { self: true, ack: true } }`; desinscription obligatoire via les helpers `releaseBroadcastChannel`/`acquireBroadcastChannel`

- Mutations synchronisees
  - `startClientConversation`, `startAdminConversation`, `archiveClientConversation`, `setAdminConversationArchived`, `sendMessage|sendFile|sendResource`, `clearChatHistory` publient `conversation` ou `message` apres succes SQL
  - Les hooks `useClientLiveChat` et `getOrCreateConversation.subscribeToMessages` consomment ces payloads pour mettre a jour React Query et l'UI sans refetch global

- Status & archivage
  - Etats: `ouvert`, `en_cours`, `a_traiter`, `resolu`, `abandonne`; les vues admin considerent `resolu|abandonne` comme archives
  - Client: `toggleArchive` -> RPC `client_chat_set_archived` -> broadcast `conversation`
  - Admin: `ConversationList` -> helper `setAdminConversationArchived` -> broadcast `conversation`

- Securite & conformite
  - Client RLS: `client_update_chat_last_viewed`, acces restreint aux colonnes `client_archived`, `client_last_viewed_at`
  - Admin: RPCs `admin_chat_set_archived`, `admin_get_chat_conversations_with_details` en security definer; aucun update direct sur les tables publiques

- Performance & maintenance
  - Preferer `queryClient.setQueryData` et tri local aux invalidations massives
  - Throttle scheduler (`scheduleConversationsRefetch`) pour limiter la charge
  - Toujours liberer les canaux broadcast a l'unmount pour eviter les fuites