Contexte
•	Frontend React 18 / Vite 7, backend Supabase (auth, données, temps réel, stockage).

Principes généraux
•	Workspace : C:\dev\notionlab ; travailler uniquement dans ce projet Vite/React via VSCode.
•	Source of truth : dossier /rules. Toujours mettre à jour quand de nouvelles architectures / logiques / dépendances  / tables sur supabase / RPC / Edge Functions arrivent.
•	Style React : fonctionnel, déclaratif, modulaire (composant ? sous-composants ? hooks/helpers ? données statiques).
•	Nommage : objets DB en snake_case, Edge Functions en kebab-case, alias Vite @ pour les imports.

Environnement & secrets

•	Env via /.env & /.env.local (ex. VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY) ; alerter si manquants ; ne jamais exposer de clés service-role côté client.

Authentification & routes
•	Séparer strictement contenus Admin vs Client.
•	Les admins sont redirigés vers /admin/dashboard.


Données, RPC & Edge Functions
•	Favoriser RPCs et Edge Functions pour la logique métier et l’accès privilégié (RLS par défaut).
•	Ajouter index DB avant livraison si nécessaires.
•	Utiliser des upsert explicites et des enum defaults.


Realtime
•	Préférer broadcast channels : supabase.channel(...).on('broadcast', ...) avec ack/self ; nommer les canaux explicitement ; dispose on unmount.
•	N’utiliser postgres_changes que si inévitable.


Stockage
•	Garder DB et Storage en phase (avatars, ressources, pièces jointes chat/forum) selon conventions de buckets.


UI/UX & accessibilité
•	Stack UI : Radix + Tailwind, react-hook-form, Zustand (état partagé), framer-motion (animations subtiles), @dnd-kit (drag/drop), React Flow (builders).
•	Interactions accessibles (focus, rôles, labels).
•	Langue : français uniquement, tutoiement. Disclaimer minimal sous « Valider » interdisant les données sensibles.


Thème & CSS
•	Theme system : couleurs via variables CSS --colors-* injectées par ThemeContext (RPC get_active_theme_tokens) et utilisées via hsl(var(--colors-…)) dans tailwind.config.js. Fallbacks :root dans src/index.css pour éviter le flash initial.
•	Compat CSS : fournir la paire standard + préfixée pour backdrop-filter et text-size-adjust (-webkit-…).
•	ThemeProvider présent uniquement dans src/main.jsx (retiré de src/App.jsx) pour éviter doubles injections/effets de bord.


Kanban & dashboards
•	Réutiliser AdminKanbanView, UserKanbanDashboard + hooks associés ; ne pas dupliquer la logique, étendre par composition.
•	Interagir avec component_rules, modules_registry, et RPCs/EF dashboard (get-dashboard-layout, update-dashboard-layout) plutôt que des toggles en dur.


Cache, invalidation & logs
•	Sur mises à jour sensibles au cache : appeler emitSessionRefresh ou invalider les requêtes pertinentes.
•	Journaliser les erreurs de façon structurée ; toasts conviviaux (sans détails sensibles).


Sécurité DB & RLS
•	Tout doit respecter la RLS ; escalader en Edge Functions pour l’accès privilégié.


CI / Dév
•	Node 20 : pipeline npm ci ? npm run build ? déploiement FTPS.
•	Local : npm run dev / npm run preview ; SQL via npm run db:query / npm run db:file.


Workflows « Formations »
•	Cycle : brouillon client ? soumission ? validation admin ? Kanban live synchronisé.
•	Onboarding formation
o	UI charge uniquement les questions actives (admin activable/désactivable).
o	Wizard non bloquant, autosauvegarde, résumé côté client + admin.
o	Soumission : upsert training_onboarding_responses, mise à jour éventuelle de profiles.profession (depuis metier_activite).
o	Notification via Edge Function notify-training-onboarding (Deno) conservant Resend.
?	Secrets requis : RESEND_API_KEY, ONBOARDING_NOTIFICATION_EMAIL (fallback OWNER_EMAIL), ONBOARDING_EMAIL_FROM (fallback SENDER_EMAIL).
?	CORS : POST, OPTIONS.
o	Restitution : page client « Mes préférences de formation » (bouton « Mettre à jour ») ; panneau admin « Brief & Profil » (lecture seule) dans le Kanban Formation Live.


Assistant IA (WebRTC Realtime)
•	Accès : bouton nav Assistant (component_key nav:assistant) et module dashboard client_ai_assistant.
•	Contexte : AssistantProvider (wrappé dans App.jsx) expose useAssistant() et encapsule Perfect Negotiation (peer « polite »).
•	Backend Supabase :
o	Tables : assistant_settings (config), assistant_limits (quotas par utilisateur), assistant_metrics (journal sessions).
o	Edge Function assistant-mint-key : clé éphémère Realtime (OpenAI) + ice_servers + flags (aucun secret côté client).
•	Quotas & métriques :
o	Garde locale (minutes/jour, sessions concurrentes, images/session) synchronisée avec assistant_limits.
o	Chaque session met à jour assistant_metrics (durée, images, bytes up/down, erreurs) et rafraîchit les compteurs.
•	UX : AssistantDrawer.jsx gère Appeler / Raccrocher / Webcam / Montrez-lui (images via DataChannel) ; AssistantPanel.jsx résume l’état et ouvre le drawer.


Invitations administrateur
•	UI : bouton « Inviter un utilisateur » (src/components/admin/UserManagementPanel.jsx) ? Edge Function invite-user.
•	Serveur : Supabase/functions/invite-user/index.ts
o	auth.admin.inviteUserByEmail (création/ré-utilisation)
o	Mise à jour public.profiles (user_type_id client, status = 'active').
o	Secrets Edge : SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, optionnel INVITE_REDIRECT_URL (fallback /connexion).
•	Activation : plus de « guest » ; arrivée sur /activation-invitation pour définir le mot de passe (accès client déjà actif).


Suppression de compte (full delete)
•	Objectif : effacer Auth + identités + données domaine.
•	Déclencheurs UI :
o	UserManagementPanel.jsx (icône corbeille)
o	ManageUserPage.jsx (bouton supprimer)
o	DeleteAccountSection.jsx (auto-suppression)
o	Tous appellent supabase.rpc('admin_delete_user_full', { p_user_id }).
•	Orchestration serveur : RPC public.admin_delete_user_full(uuid) (SECURITY DEFINER)
o	Nettoie : formation_module_statuses, user_formation_snapshots, user_formations, formation_submissions, tickets, ticket_replies, action_logs, chat_messages, chat_conversations, courses custom (author_id = user, course_type='custom').
o	Supprime public.profiles puis auth.admin.delete_user(p_user_id) (inclut auth.identities).
•	Autorisations : utilisateur ? auto-suppression ; owner/admin ? suppression d’autrui ; seul un owner peut supprimer un owner.


"Live Chat - Architecture

- Surfaces
  - Client: `modules/client-live-chat/ClientLiveChatPage.jsx` orchestre desormais le flux (fetch initial Supabase, canaux `client-chat-conversations-*` & `client-chat-messages-*`, tri local et marquage `client_last_viewed_at`) et delegue l'affichage aux composants `modules/client-live-chat/components/*`
  - Admin: `components/admin/AdminLiveChatPanel.jsx`, `components/admin/chat/ConversationList.jsx`, `components/admin/AdminChatView.jsx` conservent le pilotage direct des canaux admin
  - Primitifs partages: `src/lib/chatApi.js` assure la normalisation des conversations, la diffusion broadcast (`broadcastMessageChange`/`broadcastConversationChange`) et les RPC de creation/archivage cote staff

- Conversation workflows
  - Client: le Dialog "Nouvelle conversation" charge les destinataires via `client_list_chat_staff_users`, valide la selection et invoque `client_start_chat_conversation`; la page hydrate ensuite la nouvelle conversation et la selectionne (vue Active reinitialisee, recherche videe)
  - Admin: le flux reste inchange (`startAdminConversation({ staffUserId, recipient, forceNew })`) avec reutilisation conditionnelle et tri par `updated_at`

- Realtime & canaux
  - Le client gere `supabase.channel(...)` pour `client-chat-conversations-{guest}` et `client-chat-messages-{conversationId}` (config `{ broadcast: { self: true, ack: true } }`) depuis le composant, avec cleanup systematique; `chatApi.subscribeToClientChatMessages` relaie aussi les `postgres_changes` sur `chat_messages` afin de couvrir les insertions directes sans passer par les helpers broadcast
  - Les payloads `conversation`/`message` issus du hub `chat-live-admin` restent consommes cote admin via `AdminLiveChatPanel`

- Hydratation & tri des messages
  - Chaque payload client est enrichi via `hydrateMessage()` (select `chat_messages` + ressource join) avant insertion puis trie avec `sortMessagesAscending`
  - Les listes de conversations sont reclassees via `sortConversationsByUpdatedAt()` apres mutation ou broadcast

- Mutations synchronisees
  - Client: `ClientLiveChatPage` insere/supprime directement dans `chat_messages`, hydrate la reponse, met a jour le state local et marque `client_last_viewed_at` si l'utilisateur n'est pas staff
  - Admin: conserve `startAdminConversation`, `setAdminConversationArchived`, `sendMessage|File|Resource` du `chatApi` pour garantir les diffusions broadcast et la logique de fallback

- Status & archivage
  - Etats metier: `ouvert`, `en_cours`, `a_traiter`, `resolu`, `abandonne`; `resolu|abandonne` sont consideres comme auto-archives cote client
  - Client: `client_chat_set_archived` met a jour `client_archived` et declenche un broadcast; la vue Active filtre les fils auto-archives et ceux explicitement archives
  - Admin: `ConversationList` continue d'appuyer sur `setAdminConversationArchived` (RPC `admin_chat_set_archived`)

- Securite & conformite
  - Client: RLS via `client_update_chat_last_viewed`; seules les colonnes `client_archived`, `client_last_viewed_at` sont modifiees depuis le front
  - Admin: RPC `admin_chat_set_archived`, `admin_get_chat_conversations_with_details` en security definer; aucun acces direct service-role

- Performance & maintenance
  - Le client repose sur le state React : conserver `sortConversationsByUpdatedAt` / `sortMessagesAscending` pour eviter recharges reseau
  - Deconnecter systematiquement les canaux Supabase dans les cleanup d'effets afin d'eviter les fuites multi-onglets
  - Journaliser les erreurs Supabase avant toast (admin & client) pour diagnostiquer les pertes d'evenements
  - Toujours liberer les canaux broadcast a l'unmount pour eviter les fuites
  - Preferer `queryClient.setQueryData` et tri local aux invalidations massives
  - Throttle scheduler (`scheduleConversationsRefetch`) pour limiter la charge
  - Toujours liberer les canaux broadcast a l'unmount pour eviter les fuites
