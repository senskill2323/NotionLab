Contexte
•	Frontend React 18 / Vite 7, backend Supabase (auth, données, temps réel, stockage).

Principes généraux
•	Workspace : C:\dev\notionlab ; travailler uniquement dans ce projet Vite/React via VSCode.
•	Source of truth : dossier /rules. Toujours mettre à jour quand de nouvelles architectures / logiques / dépendances  / tables sur supabase / RPC / Edge Functions arrivent.
•	Style React : fonctionnel, déclaratif, modulaire (composant ? sous-composants ? hooks/helpers ? données statiques).
•	Nommage : objets DB en snake_case, Edge Functions en kebab-case, alias Vite @ pour les imports.

Environnement & secrets

•	Env via /.env & /.env.local (ex. VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY) ; alerter si manquants ; ne jamais exposer de clés service-role côté client.

Authentification & routes
•	Séparer strictement contenus Admin vs Client.
•	Les admins sont redirigés vers /admin/dashboard.


Données, RPC & Edge Functions
•	Favoriser RPCs et Edge Functions pour la logique métier et l’accès privilégié (RLS par défaut).
•	Ajouter index DB avant livraison si nécessaires.
•	Utiliser des upsert explicites et des enum defaults.


Realtime
•	Préférer broadcast channels : supabase.channel(...).on('broadcast', ...) avec ack/self ; nommer les canaux explicitement ; dispose on unmount.
•	N’utiliser postgres_changes que si inévitable.


Stockage
•	Garder DB et Storage en phase (avatars, ressources, pièces jointes chat/forum) selon conventions de buckets.


UI/UX & accessibilité
•	Stack UI : Radix + Tailwind, react-hook-form, Zustand (état partagé), framer-motion (animations subtiles), @dnd-kit (drag/drop), React Flow (builders).
•	Interactions accessibles (focus, rôles, labels).
•	Langue : français uniquement, tutoiement. Disclaimer minimal sous « Valider » interdisant les données sensibles.


Thème & CSS
•	Theme system : couleurs via variables CSS --colors-* injectées par ThemeContext (RPC get_active_theme_tokens) et utilisées via hsl(var(--colors-…)) dans tailwind.config.js. Fallbacks :root dans src/index.css pour éviter le flash initial.
•	Compat CSS : fournir la paire standard + préfixée pour backdrop-filter et text-size-adjust (-webkit-…).
•	ThemeProvider présent uniquement dans src/main.jsx (retiré de src/App.jsx) pour éviter doubles injections/effets de bord.


Kanban & dashboards
•	Réutiliser AdminKanbanView, UserKanbanDashboard + hooks associés ; ne pas dupliquer la logique, étendre par composition.
•	Interagir avec component_rules, modules_registry, et RPCs/EF dashboard (get-dashboard-layout, update-dashboard-layout) plutôt que des toggles en dur.


Cache, invalidation & logs
•	Sur mises à jour sensibles au cache : appeler emitSessionRefresh ou invalider les requêtes pertinentes.
•	Journaliser les erreurs de façon structurée ; toasts conviviaux (sans détails sensibles).


Sécurité DB & RLS
•	Tout doit respecter la RLS ; escalader en Edge Functions pour l’accès privilégié.


CI / Dév
•	Node 20 : pipeline npm ci ? npm run build ? déploiement FTPS.
•	Local : npm run dev / npm run preview ; SQL via npm run db:query / npm run db:file.


Workflows « Formations »
•	Cycle : brouillon client ? soumission ? validation admin ? Kanban live synchronisé.
•	Onboarding formation
o	UI charge uniquement les questions actives (admin activable/désactivable).
o	Wizard non bloquant, autosauvegarde, résumé côté client + admin.
o	Soumission : upsert training_onboarding_responses, mise à jour éventuelle de profiles.profession (depuis metier_activite).
o	Notification via Edge Function notify-training-onboarding (Deno) conservant Resend.
?	Secrets requis : RESEND_API_KEY, ONBOARDING_NOTIFICATION_EMAIL (fallback OWNER_EMAIL), ONBOARDING_EMAIL_FROM (fallback SENDER_EMAIL).
?	CORS : POST, OPTIONS.
o	Restitution : page client « Mes préférences de formation » (bouton « Mettre à jour ») ; panneau admin « Brief & Profil » (lecture seule) dans le Kanban Formation Live.


Assistant IA (WebRTC Realtime)
•	Accès : bouton nav Assistant (component_key nav:assistant) et module dashboard client_ai_assistant.
•	Contexte : AssistantProvider (wrappé dans App.jsx) expose useAssistant() et encapsule Perfect Negotiation (peer « polite »).
•	Backend Supabase :
o	Tables : assistant_settings (config), assistant_limits (quotas par utilisateur), assistant_metrics (journal sessions).
o	Edge Function assistant-mint-key : clé éphémère Realtime (OpenAI) + ice_servers + flags (aucun secret côté client).
•	Quotas & métriques :
o	Garde locale (minutes/jour, sessions concurrentes, images/session) synchronisée avec assistant_limits.
o	Chaque session met à jour assistant_metrics (durée, images, bytes up/down, erreurs) et rafraîchit les compteurs.
•	UX : AssistantDrawer.jsx gère Appeler / Raccrocher / Webcam / Montrez-lui (images via DataChannel) ; AssistantPanel.jsx résume l’état et ouvre le drawer.


Invitations administrateur
•	UI : bouton « Inviter un utilisateur » (src/components/admin/UserManagementPanel.jsx) ? Edge Function invite-user.
•	Serveur : Supabase/functions/invite-user/index.ts
o	auth.admin.inviteUserByEmail (création/ré-utilisation)
o	Mise à jour public.profiles (user_type_id client, status = 'active').
o	Secrets Edge : SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, optionnel INVITE_REDIRECT_URL (fallback /connexion).
•	Activation : plus de « guest » ; arrivée sur /activation-invitation pour définir le mot de passe (accès client déjà actif).


Suppression de compte (full delete)
•	Objectif : effacer Auth + identités + données domaine.
•	Déclencheurs UI :
o	UserManagementPanel.jsx (icône corbeille)
o	ManageUserPage.jsx (bouton supprimer)
o	DeleteAccountSection.jsx (auto-suppression)
o	Tous appellent supabase.rpc('admin_delete_user_full', { p_user_id }).
•	Orchestration serveur : RPC public.admin_delete_user_full(uuid) (SECURITY DEFINER)
o	Nettoie : formation_module_statuses, user_formation_snapshots, user_formations, formation_submissions, tickets, ticket_replies, action_logs, chat_messages, chat_conversations, courses custom (author_id = user, course_type='custom').
o	Supprime public.profiles puis auth.admin.delete_user(p_user_id) (inclut auth.identities).
•	Autorisations : utilisateur ? auto-suppression ; owner/admin ? suppression d’autrui ; seul un owner peut supprimer un owner.


"Live Chat - Architecture

- Surfaces
  - Client: `modules/client-live-chat/ClientLiveChatPage.jsx` reste l'orchestrateur (chargement via `supabase.rpc('get_chat_conversations_with_details')`, wiring `ClientConversationView`). Toutes les ecritures passent par `chatApi` (`sendMessage|sendFile|sendResource`, `archiveClientConversation`, `markConversationViewedByClient`) pour conserver les diffusions broadcast et la normalisation.
  - Widget: `components/ChatWidget.jsx` reutilise les memes helpers `chatApi` (creation conversation, envoi, archivage) afin de poser `sender='user'`, declencher les broadcast et reappliquer les validations RPC.
  - Admin: `components/admin/AdminLiveChatPanel.jsx` et `AdminChatView.jsx` consomment les donnees, mais deleguent toutes les mutations (`startAdminConversation`, `setAdminConversationArchived`, `sendMessage|sendFile|sendResource`, marquage lecture) a `chatApi`.
  - API unique: `src/lib/chatApi.js` centralise la normalisation, la gestion des canaux broadcast et les appels RPC/Edge Functions. Aucun composant ne touche directement `supabase.from('chat_messages')` ou `supabase.from('chat_conversations')`.

- Flux realtime
  - Tous les canaux `supabase.channel` sont crees avec `{ broadcast: { self: true, ack: true } }` et referencees dans `broadcastChannelRegistry`; les surfaces liberent ensuite la ressource via `releaseBroadcastChannel` dans leurs cleanups.
  - `broadcastMessageChange` et `broadcastConversationChange` restent le chemin nominal (faible latence, pas de reevaluation RLS). Le fallback `postgres_changes` de `subscribeToClientChatMessages` n'est maintenu que tant que `AdminChatView` et `ChatWidget` n'emet pas encore de broadcast; il devra etre retire des que le refactor est merge pour eviter le double cout.
  - Les payloads broadcast sont consommes tels quels; l'hydratation SQL n'est declenchee que si le message recu est partiel (legacy).

- Mutations communes
  - Client et widget: creation via `client_start_chat_conversation`, envoi par `chatApi.sendMessage|sendFile|sendResource`, archivage `archiveClientConversation`, lecture `markConversationViewedByClient`.
  - Admin: nouveaux fils via `startAdminConversation`, archivage `setAdminConversationArchived`, envoi `chatApi.sendMessage|sendFile|sendResource`, lecture via un RPC `admin_mark_chat_viewed` (a livrer) qui met a jour `admin_last_viewed_at` sous RLS.
  - Aucun composant ne doit inserer ou mettre a jour `chat_messages` / `chat_conversations` sans passer par ces helpers.

- Statuts et archivage
  - Statuts valides: `ouvert`, `en_cours`, `a_traiter`, `resolu`, `abandonne`; `resolu` et `abandonne` restent auto-archives cote client.
  - Toutes les bascules de statut/archivage passent par les RPC security definer (`client_chat_set_archived`, `admin_chat_set_archived`) qui declenchent ensuite `broadcastConversationChange`.

- Securite & RLS
  - Activer `row level security` sur `public.chat_conversations` et `public.chat_messages`, puis definir:
    - policies clients: appartenance via `guest_id`, `profiles.chat_guest_id` ou email.
    - policies staff: roles `owner|admin|prof` via `profiles.user_type` / `user_types`.
    - policies widget: correspondance sur `guest_id` pour les visiteurs anonymes.
  - Une fois RLS active, deplacer `markConversationViewedByClient` et le marquage admin dans des RPC security definer (`client_mark_chat_viewed`, `admin_mark_chat_viewed`) utilises par `chatApi`.
  - Les colonnes `sender` restent strictement `user`, `admin`, `owner`, `prof`; bannir les alias texte (ex: `guest`, prenom) afin de conserver les calculs `has_unread`.

- Performance & observabilite
  - Supprimer l'hydratation SQL pour chaque evenement dans `subscribeToClientChatMessages` des que les surfaces emettent des payloads complets; sinon, mettre en file d'attente et mutualiser les lectures.
  - Coupler les toasts utilisateurs avec un `console.error` structure afin de suivre les echecs dans les logs Supabase / Edge.
  - Tous les hooks realtime detruisent leurs canaux dans les cleanups pour eviter les fuites multi-onglets; `broadcastChannelRegistry` reste la source de verite des refCount.
