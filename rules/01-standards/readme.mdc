Framworks:

React + Vite forment le cœur, Tailwind/Radix/TipTap composent la couche UI, Zustand/Tanstack Query gèrent l’état, dnd-kit/React Flow assurent les interactions complexes, et Supabase fournit l’auth, la base temps réel et le stockage — le tout empaqueté via npm/Node 20.

Inventaire des technologies utilisée pour le projet: 

Base stack : Frontend React 18 avec Vite 7, backend Supabase (auth, base Postgres, realtime, stockage). Node 20 côté build/CI.
UI & état : Tailwind CSS + Radix UI comme socle, react-hook-form pour les formulaires, Zustand pour l’état partagé, framer-motion pour les animations, @dnd-kit pour le drag/drop, React Flow pour les builders visuels.
Accès données : RPC Postgres et fonctions Edge (Deno/TypeScript) pour toute logique privilégiée ; RLS activée sur les tables sensibles. Chat, assistant, modules formation passent par des helpers chatApi/assistantApi.
Realtime : Channels Supabase en broadcast (ack/self) orchestrés par des helpers (subscriptions unifiées, fallback hydratation).
CI/CD & scripts : npm (npm ci / npm run build / npm run dev/preview), exécution SQL via npm run db:query/db:file, déploiement FTPS.
Edge Functions actives : assistant-mint-key / voice-preview, notify-training-onboarding, invite-user, delete-user-full, create-user-with-role, content-blocks-search, manage-content-block, dashboard layout helpers, set-user-password, users-search, etc.

## Workflow Modification 

**** REGLES CRITIQUES - TOUJOURS SUIVRE CES REGLES ****
- La base avant de coder, c'est de comparer avec la bilbiothèque REF (le seul outil MCP que tu possèdes) 
- Avant de modifier un fichier, tu dois lire minimum 3 fichiers qui vont t'aider à faire quelque chose de cohérent et consistant. c'est non négociable. Tu ne dois pas skip cette étape sous aucune circonstance. 
Lire des fichiers existants assure: 
persistance du code avec les pattern du projet
- compréhension solide des conventions
- suivre l'architecutre etablie
- eviter les changements qui cassent le code. 

***Types de fichiers que tu DOIS lire*** :

1. Fichiers similaires : Lis des fichiers qui offrent une fonctionnalité comparable pour comprendre les patterns et les conventions.
2. Dépendances importées : Lis la définition/l’implémentation de tout import dont tu n’es pas sûr à 100 % de l’usage correct — comprends leur API, leurs types et leurs modes d’utilisation.


** Etapes à suivre **
1. Lire au minimum 3 fichiers existants et relatifs
2. comprendre le pattern et les conventions
3. Uniquement après, procède avec la création/l'édition d'un fichier 

* AUTRES INSTRUCTIONS * 

- Utilise le MCP ref (mcp_servers.ref) avant d’écrire du code, en cas d’API/librarie nouvelle, ou si nous doutons d’un pattern, interroge ref! si Ref ne renvoie rien de probant, le dire, proposer la meilleure approche connue + TODO “à valider via Ref/Docs”.
- Utilise powershell v7.xx installé ("C:\Program Files\PowerShell\7\pwsh.exe")
- Utilise le script Node scripts/run-sql.js (lancé comme node scripts/run-sql.js "<ta requête SQL>") pour exécuter des requêtes SQL contre Supabase. ID du projet Supabase: kiudpvvqpbkzeybogrnq (Projet NotionLab)
- Les appels “webhook” vers /functions/v1/send-email doivent être signés via Svix avec le secret d’environnement `SEND_EMAIL_HOOK_SECRET` (valeur commune front/automations) ; seul le mode test (`x-send-email-test: 1`) contourne cette vérification.
- GoTrue et les fonctions RTP utilisent le SMTP Hostinger (`SMTP_HOST`, `SMTP_USER`, `SMTP_PASS`, `SMTP_ADMIN_EMAIL`). Toute modification d'e-mails transactionnels doit tenir compte de cette configuration partagée.
